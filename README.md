# Prac-4.1-4.3
# Практическое задание, Вариант 19: Жадный алгоритм для минимального остовного дерева (Алгоритм Крускала)

## 1. Название задания

**Реализовать алгоритм Крускала с жадной стратегией для нахождения минимального остовного дерева.**

## 2. Реализация задания на C++ (в файле на github)

3. Входные данные
vector<Edge> edges = {
    {0, 1, 4}, {0, 2, 3}, {1, 2, 1}, {1, 3, 2},
    {2, 3, 4}, {2, 4, 2}, {3, 4, 3}, {3, 5, 2}, {4, 5, 6}
};
Выходные данные
Ребра минимального остовного дерева:
1 - 2 (вес 1)
1 - 3 (вес 2)
3 - 5 (вес 2)
0 - 2 (вес 3)
2 - 4 (вес 2)
Общий вес MST: 10

4. Анализ работы алгоритма
1. Создание структуры Edge: Для представления ребра графа создается структура Edge, содержащая индексы вершин u и v, а также вес weight. Оператор operator< позволяет сортировать ребра по возрастанию веса.
```
struct Edge {
    int u, v, weight;
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};
```
2. Инициализация UnionFind: Создается объект dsu класса UnionFind, размером numVertices. Это инициализирует parent массив, где каждый элемент указывает на себя (каждая вершина изначально в своем множестве), и rank массив, заполненный нулями.
```
UnionFind dsu(numVertices);
```
3. Сортировка ребер: Входной список ребер edges сортируется по возрастанию веса. Это ключевой шаг жадной стратегии
```
sort(edges.begin(), edges.end());
```
4. Инициализация результата: Создаются пустой вектор mst для хранения ребер минимального остовного дерева и переменная totalWeight для суммирования весов.
```
vector<Edge> mst;
int totalWeight = 0;
```
5. Цикл по отсортированным ребрам: Алгоритм перебирает ребра в отсортированном порядке.
```
for (const Edge& e : edges) {
```
6. Проверка цикла (find): Для текущего ребра e проверяется, принадлежат ли вершины e.u и e.v одному и тому же множеству (имеют ли они одинаковый корень). Если dsu.find(e.u) != dsu.find(e.v), это означает, что добавление этого ребра не создаст цикл.
```
if (dsu.find(e.u) != dsu.find(e.v)) {
```
7. Добавление ребра в MST: Если цикла нет, ребро e добавляется в вектор mst, его вес прибавляется к totalWeight.
```
mst.push_back(e);
totalWeight += e.weight;
```
8. Объединение множеств (unite): Вызывается метод dsu.unite(e.u, e.v), который объединяет множества, содержащие вершины u и v. Это делается с учетом ранга для оптимизации.
```
dsu.unite(e.u, e.v);
```
9. Проверка завершения: После добавления ребра проверяется, не достигло ли количество ребер в mst значения numVertices - 1. Если да, MST построен, и цикл можно прервать.
```
if (mst.size() == numVertices - 1) {
    break;
}
```
10. Возврат результата: После завершения цикла возвращается пара: вектор mst и totalWeight.
```
return {mst, totalWeight};
```

5. Временная сложность алгоритма
O(E * log E + E * α(V)), где E — количество ребер, V — количество вершин, α — обратная функция Аккермана (практически константа).
Часто упрощается до O(E * log E).

6. Объяснение временной сложности алгоритма
Сортировка ребер: Основной вклад в сложность вносит сортировка. Сортировка E ребер требует O(E * log E) времени.
Цикл по ребрам: Цикл for выполняется до E раз.
Операции find и unite: Внутри цикла выполняются операции dsu.find() и dsu.unite(). При использовании "сжатия путей" в find и "объединения по рангу" в unite, амортизированная сложность каждой операции составляет O(α(V)), где α — обратная функция Аккермана, растущая экстремально медленно (практически константа для реальных размеров V).
Общая сложность цикла: E итераций по O(α(V)) дают O(E * α(V)).
Суммарная сложность: Сложность сортировки O(E * log E) доминирует над O(E * α(V)). Следовательно, общая временная сложность алгоритма Крускала определяется сортировкой и составляет O(E * log E).

